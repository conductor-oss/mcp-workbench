import { Transport } from "@modelcontextprotocol/sdk/shared/transport.js";
import { JSONRPCMessage } from "@modelcontextprotocol/sdk/types.js";

/**
 * A non-standard Transport that sends messages via HTTP POST and expects
 * the JSON-RPC response to be returned immediately in the HTTP response body.
 * 
 * This bypasses the SSE requirement of standard MCP.
 */
export class DirectClientTransport implements Transport {
    private _url: URL;
    private _headers: Record<string, string>;

    onclose?: () => void;
    onerror?: (error: Error) => void;
    onmessage?: (message: JSONRPCMessage) => void;

    constructor(url: URL, headers: Record<string, string> = {}) {
        this._url = url;
        this._headers = headers;
    }

    async start(): Promise<void> {
        // No connection setup needed for stateless HTTP
        console.log("[DirectClientTransport] Ready. URL:", this._url.toString());
    }

    async close(): Promise<void> {
        this.onclose?.();
    }

    async send(message: JSONRPCMessage): Promise<void> {
        try {
            console.log("[DirectClientTransport] Sending:", message);

            const headers: Record<string, string> = {
                'Content-Type': 'application/json',
                'Accept': 'application/json', // We prefer direct JSON response
                ...this._headers
            };

            const response = await fetch(this._url, {
                method: 'POST',
                headers,
                body: JSON.stringify(message)
            });

            if (!response.ok) {
                const text = await response.text();
                throw new Error(`HTTP Error ${response.status}: ${text}`);
            }

            // Lifecycle: Capture Server-assigned Session ID
            const sessionId = response.headers.get('mcp-session-id');
            if (sessionId) {
                if (this._headers['MCP-Session-Id'] !== sessionId) {
                    console.log("[DirectClientTransport] New Session ID captured:", sessionId);
                    this._headers['MCP-Session-Id'] = sessionId;
                }
            }

            // Streamable HTTP: 
            // - 202 Accepted -> Notification accepted (no response body expected for notifications)
            // - 200 OK + application/json -> JSON-RPC Response
            if (response.status === 202) {
                return;
            }

            const contentType = response.headers.get('content-type');
            if (contentType && contentType.includes('application/json')) {
                const data = await response.json();
                console.log("[DirectClientTransport] Received:", data);

                // If the server assigned a session ID, we should technically capture it.
                // However, Context manages headers. We might need a way to bubble headers up?
                // For now, we assume the initial session ID generated by context is sufficient or the server uses it.

                if (this.onmessage) {
                    this.onmessage(data);
                }
            } else {
                // Technically 200 OK without JSON body is weird for a Request, but okay.
                console.warn("[DirectClientTransport] Received non-JSON response:", contentType);
            }

        } catch (error: any) {
            console.error("[DirectClientTransport] Error:", error);
            if (this.onerror) {
                this.onerror(error);
            }
        }
    }
}
